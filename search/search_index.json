{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview RISC-V PVP is a modular and parameterized RISC-V Processor Verification Platform. It currently supports the following features: Supported RISC-V ISA: RV32G RV64G C Extension, 2.0 V Extension, 0.10 YAML based hand-written sequence templates numpy based golden data for vector ISA Easy to support new ISAs Easy to add new cases End-to-end RTL&ISS co-simulation flow Motivation Open source RISC-V processor verification solutions such as riscv-tests, riscv-arch-test have provided good sanity verifications for RISCV basic ISAs, but new extensions(for example, Vector, Bitmanip) support is missing. Our motivation is build a high quality open source verification platform to support more extensions easily to improve the verification quality of RISC-V processors. Issues Please file an issue under this repository for any bug report / integration issue / feature request. We are looking forward to knowing your experience of using this flow and how we can make it better together. License MIT License Copyright \u00a9 2020-2021 UltraFive Team Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Overview"},{"location":"#overview","text":"RISC-V PVP is a modular and parameterized RISC-V Processor Verification Platform. It currently supports the following features: Supported RISC-V ISA: RV32G RV64G C Extension, 2.0 V Extension, 0.10 YAML based hand-written sequence templates numpy based golden data for vector ISA Easy to support new ISAs Easy to add new cases End-to-end RTL&ISS co-simulation flow","title":"Overview"},{"location":"#motivation","text":"Open source RISC-V processor verification solutions such as riscv-tests, riscv-arch-test have provided good sanity verifications for RISCV basic ISAs, but new extensions(for example, Vector, Bitmanip) support is missing. Our motivation is build a high quality open source verification platform to support more extensions easily to improve the verification quality of RISC-V processors.","title":"Motivation"},{"location":"#issues","text":"Please file an issue under this repository for any bug report / integration issue / feature request. We are looking forward to knowing your experience of using this flow and how we can make it better together.","title":"Issues"},{"location":"#license","text":"MIT License Copyright \u00a9 2020-2021 UltraFive Team Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"cosim/","text":"Co-Simulation Flow","title":"Co-Simulation"},{"location":"cosim/#co-simulation-flow","text":"","title":"Co-Simulation Flow"},{"location":"get-started/","text":"Getting Started Prerequisites export RISCV = ~/opt/riscv Toolchains For latest rvv-0.10/1.0 support, we use llvm as the default toolchain. We could build it from source and install to $RISCV. $ git clone https://github.com/ultrafive/llvm-project $ cd llvm-project $ git checkout uf-master $ mkdir -p build && cd build && cmake -DCMAKE_INSTALL_PREFIX = $RISCV \\ -DCMAKE_BUILD_TYPE = Release -DLLVM_OPTIMIZED_TABLEGEN = On \\ -DLLVM_ENABLE_PROJECTS = \"clang;compiler-rt;lld\" \\ -DLLVM_LINK_LLVM_DYLIB = On ../llvm $ make -j ` nproc ` && make install llvm's libc development is still in the planning phase. To support c compiling, we still need a external libc. Let\u2018s build riscv-gnu-toolchain from source and install to $RISCV. $ git clone https://github.com/riscv/riscv-gnu-toolchain $ cd riscv-gnu-toolchain $ git checkout rvv-0.9.x $ git submodule update --init --recursive $ mkdir -p build && cd build && ../configure --prefix = $RISCV $ make -j ` nproc ` Instruction Set Simulators The default Instruction Set Simulator (ISS) is spike. We are working in progress to support more ISSs. $ git clone https://github.com/riscv/riscv-tools $ cd riscv-tools $ git submodule update --init --recursive $ cd riscv-isa-sim && git checkout master && git pull && cd .. $ ./build-spike-only.sh RTL Simulators To use the co-simulation flow, you need to have an RTL simulator which supports RISC-V Vector Extension 0.10/1.0. The RTL simulator also need to use \"+signature=\" argument provide a way to dump the \"begin_signature\" section to a file, this machanism is also used by riscv-torture or other RISC-V co-simulation flows. We have verified with Synopsys VCS, verilator in chipyard framework. Please make sure the EDA tool environment is properly setup before running the co-simulation flow. Install RISCV-PVP Getting the source from github. git clone https://github.com/ultrafive/riscv-pvp.git Install dependencies and run. cd riscv-pvp pip3 install -r requirements.txt # install dependencies (only once) python3 run.py --help Run verification with default spike ISS: python3 ./run.py Run verification with default spike ISS and diff with vcs RTL simulator: python3 ./run.py --vcs = <simv_path>","title":"Getting Started"},{"location":"get-started/#getting-started","text":"","title":"Getting Started"},{"location":"get-started/#prerequisites","text":"export RISCV = ~/opt/riscv","title":"Prerequisites"},{"location":"get-started/#toolchains","text":"For latest rvv-0.10/1.0 support, we use llvm as the default toolchain. We could build it from source and install to $RISCV. $ git clone https://github.com/ultrafive/llvm-project $ cd llvm-project $ git checkout uf-master $ mkdir -p build && cd build && cmake -DCMAKE_INSTALL_PREFIX = $RISCV \\ -DCMAKE_BUILD_TYPE = Release -DLLVM_OPTIMIZED_TABLEGEN = On \\ -DLLVM_ENABLE_PROJECTS = \"clang;compiler-rt;lld\" \\ -DLLVM_LINK_LLVM_DYLIB = On ../llvm $ make -j ` nproc ` && make install llvm's libc development is still in the planning phase. To support c compiling, we still need a external libc. Let\u2018s build riscv-gnu-toolchain from source and install to $RISCV. $ git clone https://github.com/riscv/riscv-gnu-toolchain $ cd riscv-gnu-toolchain $ git checkout rvv-0.9.x $ git submodule update --init --recursive $ mkdir -p build && cd build && ../configure --prefix = $RISCV $ make -j ` nproc `","title":"Toolchains"},{"location":"get-started/#instruction-set-simulators","text":"The default Instruction Set Simulator (ISS) is spike. We are working in progress to support more ISSs. $ git clone https://github.com/riscv/riscv-tools $ cd riscv-tools $ git submodule update --init --recursive $ cd riscv-isa-sim && git checkout master && git pull && cd .. $ ./build-spike-only.sh","title":"Instruction Set Simulators"},{"location":"get-started/#rtl-simulators","text":"To use the co-simulation flow, you need to have an RTL simulator which supports RISC-V Vector Extension 0.10/1.0. The RTL simulator also need to use \"+signature=\" argument provide a way to dump the \"begin_signature\" section to a file, this machanism is also used by riscv-torture or other RISC-V co-simulation flows. We have verified with Synopsys VCS, verilator in chipyard framework. Please make sure the EDA tool environment is properly setup before running the co-simulation flow.","title":"RTL Simulators"},{"location":"get-started/#install-riscv-pvp","text":"Getting the source from github. git clone https://github.com/ultrafive/riscv-pvp.git Install dependencies and run. cd riscv-pvp pip3 install -r requirements.txt # install dependencies (only once) python3 run.py --help Run verification with default spike ISS: python3 ./run.py Run verification with default spike ISS and diff with vcs RTL simulator: python3 ./run.py --vcs = <simv_path>","title":"Install RISCV-PVP"},{"location":"custom/cases/","text":"Add new cases Verification cases should be defined following this template. vadd_vi : # test group name, use the instrution name for isa cases env : RVTEST_RV64UV # test env macro with init, defined in riscv_test.h head : | # #include \"exception.h\" #include \"test_macros_v.h\" templates : # test case templates test_vxxx_vi_without_mask @ vs2, imm, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; vsetvli t0, a0, e{ebits},m1,tu,mu; la a2, {vs2_data}; {ldins} v2, (a2); {name} v3, v2, {imm}; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection test_vxxx_vi_with_mask @ vs2, imm, mask, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; la a2, {vs2_data}; la a4, {mask_data}; li t1, 8; remu t2, a0, t1; bnez t2, 1f; li t3, {vlen} / 8; j 2f; 1: li t3, {vlen} / 8 + 1; 2: vsetvli t0, t3, e8,m1,tu,mu; vle8.v v0, (a4); vsetvli t0, a0, e{ebits},m1,tu,mu; {ldins} v2, (a2); {name} v3, v2, {imm}, v0.t; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection cases : # test cases by passing parameters to defined templates test_vxxx_vi_without_mask : - '[np.array([4], dtype=np.int32), 4, 1]' - '[np.array([-2], dtype=np.int32), 3, 1]' - '[np.linspace(0, 0xffff, 16, dtype=np.int32), 9, 16]' - '[np.linspace(0, 0xffffffff, 31, dtype=np.int32), 13, 31]' - '[np.linspace(0, 0xffffffff, 32, dtype=np.int32), 15, 32]' test_vxxx_vi_with_mask : - '[np.array([4], dtype=np.int32), 4, np.array([0x5a], dtype=np.uint8), 1]' - '[np.linspace(0, 0xffff, 16, dtype=np.int32), 3, np.array([0x5a, 0xa5], dtype=np.uint8), 16]' - '[np.linspace(0, 0xffffffff, 31, dtype=np.int32), 9, np.linspace(0, 255, 4, dtype=np.uint8), 31]' - '[np.linspace(0, 0xffffffff, 32, dtype=np.int32), 15, np.linspace(0, 255, 4, dtype=np.uint8), 32]' check : # check simulate result with python golden test_vxxx_vi_without_mask : np.array_equal(result, golden) test_vxxx_vi_with_mask : np.array_equal(result, golden)","title":"Cases"},{"location":"custom/cases/#add-new-cases","text":"Verification cases should be defined following this template. vadd_vi : # test group name, use the instrution name for isa cases env : RVTEST_RV64UV # test env macro with init, defined in riscv_test.h head : | # #include \"exception.h\" #include \"test_macros_v.h\" templates : # test case templates test_vxxx_vi_without_mask @ vs2, imm, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; vsetvli t0, a0, e{ebits},m1,tu,mu; la a2, {vs2_data}; {ldins} v2, (a2); {name} v3, v2, {imm}; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection test_vxxx_vi_with_mask @ vs2, imm, mask, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; la a2, {vs2_data}; la a4, {mask_data}; li t1, 8; remu t2, a0, t1; bnez t2, 1f; li t3, {vlen} / 8; j 2f; 1: li t3, {vlen} / 8 + 1; 2: vsetvli t0, t3, e8,m1,tu,mu; vle8.v v0, (a4); vsetvli t0, a0, e{ebits},m1,tu,mu; {ldins} v2, (a2); {name} v3, v2, {imm}, v0.t; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection cases : # test cases by passing parameters to defined templates test_vxxx_vi_without_mask : - '[np.array([4], dtype=np.int32), 4, 1]' - '[np.array([-2], dtype=np.int32), 3, 1]' - '[np.linspace(0, 0xffff, 16, dtype=np.int32), 9, 16]' - '[np.linspace(0, 0xffffffff, 31, dtype=np.int32), 13, 31]' - '[np.linspace(0, 0xffffffff, 32, dtype=np.int32), 15, 32]' test_vxxx_vi_with_mask : - '[np.array([4], dtype=np.int32), 4, np.array([0x5a], dtype=np.uint8), 1]' - '[np.linspace(0, 0xffff, 16, dtype=np.int32), 3, np.array([0x5a, 0xa5], dtype=np.uint8), 16]' - '[np.linspace(0, 0xffffffff, 31, dtype=np.int32), 9, np.linspace(0, 255, 4, dtype=np.uint8), 31]' - '[np.linspace(0, 0xffffffff, 32, dtype=np.int32), 15, np.linspace(0, 255, 4, dtype=np.uint8), 32]' check : # check simulate result with python golden test_vxxx_vi_without_mask : np.array_equal(result, golden) test_vxxx_vi_with_mask : np.array_equal(result, golden)","title":"Add new cases"},{"location":"custom/instructions/","text":"Add New Instructions To support new instructions, we should create a new Inst class in isa/ directory. The new class inherits from the Inst class and should override these members and methods: name : the instruction name string golden(): return how to get dest op from source ops. # isa/rvi/add.py from isa.inst import * class Add ( Inst ): name = 'add' def golden ( self ): rd = self [ 'rs1' ] + self [ 'rs2' ] return rd","title":"Instructions"},{"location":"custom/instructions/#add-new-instructions","text":"To support new instructions, we should create a new Inst class in isa/ directory. The new class inherits from the Inst class and should override these members and methods: name : the instruction name string golden(): return how to get dest op from source ops. # isa/rvi/add.py from isa.inst import * class Add ( Inst ): name = 'add' def golden ( self ): rd = self [ 'rs1' ] + self [ 'rs2' ] return rd","title":"Add New Instructions"},{"location":"custom/rvg-example/","text":"RISC-V G Example _ : &default env : RVTEST_RV32U templates : test_imm_op @ rs1, imm : | TEST_IMM_OP( {num}, {name}, {res}, {rs1}, {imm} ); test_src1_eq_dest @ rs1, imm : | TEST_IMM_SRC1_EQ_DEST( {num}, {name}, {res}, {rs1}, {imm} ); test_dest_bypass @ rs1, imm, nop_cycles : | TEST_IMM_DEST_BYPASS( {num}, {nop_cycles}, {name}, {res}, {rs1}, {imm} ); test_src1_bypass @ rs1, imm, nop_cycles : | TEST_IMM_SRC1_BYPASS( {num}, {nop_cycles}, {name}, {res}, {rs1}, {imm} ); test_zerosrc1 @ imm @ rs1 = 0 : | TEST_IMM_ZEROSRC1( {num}, {name}, {res}, {imm} ); test_zerodest @ rs1, imm : | TEST_IMM_ZERODEST( {num}, {name}, {rs1}, {imm} ); addi : << : *default cases : test_imm_op : - [ 0x00000000 , 0x000 ] - [ 0x00000001 , 0x001 ] - [ 0x00000003 , 0x007 ] - [ 0x0000000000000000 , 0x800 ] - [ 0xffffffff80000000 , 0x000 ] - [ 0xffffffff80000000 , 0x800 ] - [ 0x00000000 , 0x7ff ] - [ 0x7fffffff , 0x000 ] - [ 0x7fffffff , 0x7ff ] - [ 0xffffffff80000000 , 0x7ff ] - [ 0x000000007fffffff , 0x800 ] - [ 0x0000000000000000 , 0xfff ] - [ 0xffffffffffffffff , 0x001 ] - [ 0xffffffffffffffff , 0xfff ] - [ 0x7fffffff , 0x001 ] test_src1_eq_dest : - [ 13 , 11 ] test_dest_bypass : - [ 13 , 11 , 0 ] - [ 13 , 10 , 1 ] - [ 13 , 9 , 2 ] test_src1_bypass : - [ 13 , 11 , 0 ] - [ 13 , 10 , 1 ] - [ 13 , 9 , 2 ] test_zerosrc1 : - [ 32 ] test_zerodest : - [ 33 , 50 ] slti : << : *default cases : test_imm_op : - [ 0x0000000000000000 , 0x000 ] - [ 0x0000000000000001 , 0x001 ] - [ 0x0000000000000003 , 0x007 ] - [ 0x0000000000000007 , 0x003 ] - [ 0x0000000000000000 , 0x800 ] - [ 0xffffffff80000000 , 0x000 ] - [ 0xffffffff80000000 , 0x800 ] - [ 0x0000000000000000 , 0x7ff ] - [ 0x000000007fffffff , 0x000 ] - [ 0x000000007fffffff , 0x7ff ] - [ 0xffffffff80000000 , 0x7ff ] - [ 0x000000007fffffff , 0x800 ] - [ 0x0000000000000000 , 0xfff ] - [ 0xffffffffffffffff , 0x001 ] - [ 0xffffffffffffffff , 0xfff ] test_src1_eq_dest : - [ 11 , 13 ]","title":"RVG"},{"location":"custom/rvg-example/#risc-v-g-example","text":"_ : &default env : RVTEST_RV32U templates : test_imm_op @ rs1, imm : | TEST_IMM_OP( {num}, {name}, {res}, {rs1}, {imm} ); test_src1_eq_dest @ rs1, imm : | TEST_IMM_SRC1_EQ_DEST( {num}, {name}, {res}, {rs1}, {imm} ); test_dest_bypass @ rs1, imm, nop_cycles : | TEST_IMM_DEST_BYPASS( {num}, {nop_cycles}, {name}, {res}, {rs1}, {imm} ); test_src1_bypass @ rs1, imm, nop_cycles : | TEST_IMM_SRC1_BYPASS( {num}, {nop_cycles}, {name}, {res}, {rs1}, {imm} ); test_zerosrc1 @ imm @ rs1 = 0 : | TEST_IMM_ZEROSRC1( {num}, {name}, {res}, {imm} ); test_zerodest @ rs1, imm : | TEST_IMM_ZERODEST( {num}, {name}, {rs1}, {imm} ); addi : << : *default cases : test_imm_op : - [ 0x00000000 , 0x000 ] - [ 0x00000001 , 0x001 ] - [ 0x00000003 , 0x007 ] - [ 0x0000000000000000 , 0x800 ] - [ 0xffffffff80000000 , 0x000 ] - [ 0xffffffff80000000 , 0x800 ] - [ 0x00000000 , 0x7ff ] - [ 0x7fffffff , 0x000 ] - [ 0x7fffffff , 0x7ff ] - [ 0xffffffff80000000 , 0x7ff ] - [ 0x000000007fffffff , 0x800 ] - [ 0x0000000000000000 , 0xfff ] - [ 0xffffffffffffffff , 0x001 ] - [ 0xffffffffffffffff , 0xfff ] - [ 0x7fffffff , 0x001 ] test_src1_eq_dest : - [ 13 , 11 ] test_dest_bypass : - [ 13 , 11 , 0 ] - [ 13 , 10 , 1 ] - [ 13 , 9 , 2 ] test_src1_bypass : - [ 13 , 11 , 0 ] - [ 13 , 10 , 1 ] - [ 13 , 9 , 2 ] test_zerosrc1 : - [ 32 ] test_zerodest : - [ 33 , 50 ] slti : << : *default cases : test_imm_op : - [ 0x0000000000000000 , 0x000 ] - [ 0x0000000000000001 , 0x001 ] - [ 0x0000000000000003 , 0x007 ] - [ 0x0000000000000007 , 0x003 ] - [ 0x0000000000000000 , 0x800 ] - [ 0xffffffff80000000 , 0x000 ] - [ 0xffffffff80000000 , 0x800 ] - [ 0x0000000000000000 , 0x7ff ] - [ 0x000000007fffffff , 0x000 ] - [ 0x000000007fffffff , 0x7ff ] - [ 0xffffffff80000000 , 0x7ff ] - [ 0x000000007fffffff , 0x800 ] - [ 0x0000000000000000 , 0xfff ] - [ 0xffffffffffffffff , 0x001 ] - [ 0xffffffffffffffff , 0xfff ] test_src1_eq_dest : - [ 11 , 13 ]","title":"RISC-V G Example"},{"location":"custom/rvv-example/","text":"RISC-V V Example _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_vxxx_vi_without_mask @ vs2, imm, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; vsetvli t0, a0, e{ebits},m1,tu,mu; la a2, {vs2_data}; {ldins} v2, (a2); {name} v3, v2, {imm}; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection test_vxxx_vi_with_mask @ vs2, imm, mask, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; la a2, {vs2_data}; la a4, {mask_data}; li t1, 8; remu t2, a0, t1; bnez t2, 1f; li t3, {vlen} / 8; j 2f; 1: li t3, {vlen} / 8 + 1; 2: vsetvli t0, t3, e8,m1,tu,mu; vle8.v v0, (a4); vsetvli t0, a0, e{ebits},m1,tu,mu; {ldins} v2, (a2); {name} v3, v2, {imm}, v0.t; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection cases : test_vxxx_vi_without_mask : - '[np.array([4], dtype=np.int32), 4, 1]' - '[np.array([-2], dtype=np.int32), 3, 1]' - '[np.linspace(0, 1, 16, dtype=np.int32), 9, 16]' - '[np.linspace(0, -1, -31, dtype=np.int32), 13, 31]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, 32]' test_vxxx_vi_with_mask : - '[np.array([4], dtype=np.int32), 4, np.array([0x5a], dtype=np.uint8), 1]' - '[np.linspace(0, 1, 16, dtype=np.int32), 3, np.array([0x5a, 0xa5], dtype=np.uint8), 16]' - '[np.linspace(0, -1, -31, dtype=np.int32), 9, np.linspace(0, 255, 4, dtype=np.uint8), 31]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, np.linspace(0, 255, 4, dtype=np.uint8), 32]' check : test_vxxx_vi_without_mask : np.array_equal(result, golden) test_vxxx_vi_with_mask : np.array_equal(result, golden) vadd_vi : << : *default vrsub_vi : << : *default","title":"RVV"},{"location":"custom/rvv-example/#risc-v-v-example","text":"_ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_vxxx_vi_without_mask @ vs2, imm, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; vsetvli t0, a0, e{ebits},m1,tu,mu; la a2, {vs2_data}; {ldins} v2, (a2); {name} v3, v2, {imm}; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection test_vxxx_vi_with_mask @ vs2, imm, mask, vlen @ ebits=32, ldins='vle32.v', stins='vse32.v' : | test_{num}: li TESTNUM, {num}; li a0, {vlen}; la a2, {vs2_data}; la a4, {mask_data}; li t1, 8; remu t2, a0, t1; bnez t2, 1f; li t3, {vlen} / 8; j 2f; 1: li t3, {vlen} / 8 + 1; 2: vsetvli t0, t3, e8,m1,tu,mu; vle8.v v0, (a4); vsetvli t0, a0, e{ebits},m1,tu,mu; {ldins} v2, (a2); {name} v3, v2, {imm}, v0.t; la a3, test_{num}_data; {stins} v3, (a3); .pushsection .data, 1; test_{num}_data: .fill {vlen}, ({ebits}/8), 0; .popsection cases : test_vxxx_vi_without_mask : - '[np.array([4], dtype=np.int32), 4, 1]' - '[np.array([-2], dtype=np.int32), 3, 1]' - '[np.linspace(0, 1, 16, dtype=np.int32), 9, 16]' - '[np.linspace(0, -1, -31, dtype=np.int32), 13, 31]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, 32]' test_vxxx_vi_with_mask : - '[np.array([4], dtype=np.int32), 4, np.array([0x5a], dtype=np.uint8), 1]' - '[np.linspace(0, 1, 16, dtype=np.int32), 3, np.array([0x5a, 0xa5], dtype=np.uint8), 16]' - '[np.linspace(0, -1, -31, dtype=np.int32), 9, np.linspace(0, 255, 4, dtype=np.uint8), 31]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, np.linspace(0, 255, 4, dtype=np.uint8), 32]' check : test_vxxx_vi_without_mask : np.array_equal(result, golden) test_vxxx_vi_with_mask : np.array_equal(result, golden) vadd_vi : << : *default vrsub_vi : << : *default","title":"RISC-V V Example"},{"location":"reference/cmdline/","text":"Command Line Reference ./run.py --help usage: run.py [ -h ] [ --specs SPECS ] [ --cases CASES ] [ --xlen { 32 ,64 }] [ --flen { 32 ,64 }] [ --vlen { 256 ,512,1024,2048 }] [ --elen { 32 ,64 }] [ --slen { 256 ,512,1024,2048 }] [ --clang CLANG ] [ --spike SPIKE ] [ --vcs VCS ] [ --verilator VERILATOR ] optional arguments: -h, --help show this help message and exit --specs SPECS test specs --cases CASES test cases, for example: Test_addi::test_imm_op [ 0 -0 ] --xlen { 32 ,64 } bits of int register ( xreg ) --flen { 32 ,64 } bits of float register ( freg ) --vlen { 256 ,512,1024,2048 } bits of vector register ( vreg ) --elen { 32 ,64 } bits of maximum size of vector element --slen { 256 ,512,1024,2048 } bits of vector striping distance --clang CLANG path of clang compiler --spike SPIKE path of spike simulator --vcs VCS path of vcs simulator --verilator VERILATOR path of verilator simulator","title":"Command Line"},{"location":"reference/cmdline/#command-line-reference","text":"./run.py --help usage: run.py [ -h ] [ --specs SPECS ] [ --cases CASES ] [ --xlen { 32 ,64 }] [ --flen { 32 ,64 }] [ --vlen { 256 ,512,1024,2048 }] [ --elen { 32 ,64 }] [ --slen { 256 ,512,1024,2048 }] [ --clang CLANG ] [ --spike SPIKE ] [ --vcs VCS ] [ --verilator VERILATOR ] optional arguments: -h, --help show this help message and exit --specs SPECS test specs --cases CASES test cases, for example: Test_addi::test_imm_op [ 0 -0 ] --xlen { 32 ,64 } bits of int register ( xreg ) --flen { 32 ,64 } bits of float register ( freg ) --vlen { 256 ,512,1024,2048 } bits of vector register ( vreg ) --elen { 32 ,64 } bits of maximum size of vector element --slen { 256 ,512,1024,2048 } bits of vector striping distance --clang CLANG path of clang compiler --spike SPIKE path of spike simulator --vcs VCS path of vcs simulator --verilator VERILATOR path of verilator simulator","title":"Command Line Reference"}]}